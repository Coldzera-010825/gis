{"version":"1","records":[{"hierarchy":{"lvl1":"GeoData Toolkit ğŸš€"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"GeoData Toolkit ğŸš€"},"content":"A growing collection of Python utilities for geospatial data processing, analysis, and visualisation.The goal is to keep each script self-contained and easy to reuse in day-to-day GIS workflows, whether you are a data scientist, cartographer, or researcher.","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"GeoData Toolkit ğŸš€","lvl2":"âœ¨ What you can do with this repo"},"type":"lvl2","url":"/#id-what-you-can-do-with-this-repo","position":2},{"hierarchy":{"lvl1":"GeoData Toolkit ğŸš€","lvl2":"âœ¨ What you can do with this repo"},"content":"Category\n\nCapabilities (present & planned)\n\nData processing\n\nâ€¢ Batch convert between vector/raster formats (e.g. shp â†’ tif, shp â†” kml) â€¢ Coordinate-system transformations â€¢ CRUD operations on attribute tables\n\nData analysis\n\nâ€¢ Spatial joins & overlays â€¢ Zonal statistics â€¢ Terrain & hydrological analysis (road-mapped)\n\nVisualisation\n\nâ€¢ Quick-look PNG generation for QA â€¢ Matplotlib-based thematic maps (planned)\n\nStatus: active development â€“ scripts are added & refined continuously.Pull Requests and feature ideas are welcome!","type":"content","url":"/#id-what-you-can-do-with-this-repo","position":3},{"hierarchy":{"lvl1":"GeoData Toolkit ğŸš€","lvl2":"ğŸ“‚ Current script list"},"type":"lvl2","url":"/#id-current-script-list","position":4},{"hierarchy":{"lvl1":"GeoData Toolkit ğŸš€","lvl2":"ğŸ“‚ Current script list"},"content":"Path\n\nDescription\n\nscripts/kml_ouput\n\nCreate a user-defined bounding rectangle (by centre + size / by lat-lon extent) and save it as KML.  Optional flags let you export the same rectangle as Shapefile or GeoJSON.\n\nscripts/shp2tif_workflow\n\nGeneric Shapefile â†’ GeoTIFF converter â€“ supports geometry repair, size limits, float-32 attribute rasterisation (e.g. DEPTH2D).\n\nnotebooks/batch_coordinate_transform.ipynb\n\nBatch re-projection utility: recursively scans a folder, assigns a CRS if missing, and converts all vector layers to WGS-84 (EPSG 4326). Supports Shapefile / GeoJSON / GPKG; writes a mirrored directory tree under output_root/.\n\nPlanned additions (ğŸ“… Q3 2025):\n\nscripts/clip_by_polygon â€“ vector & raster clipping\n\nnotebooks/analysis_templates/ â€“ ready-to-run Jupyter notebooks for common analyses","type":"content","url":"/#id-current-script-list","position":5},{"hierarchy":{"lvl1":"GeoData Toolkit ğŸš€","lvl2":"ğŸ”§ Quick start"},"type":"lvl2","url":"/#id-quick-start","position":6},{"hierarchy":{"lvl1":"GeoData Toolkit ğŸš€","lvl2":"ğŸ”§ Quick start"},"content":"# 1. clone\ngit clone https://github.com/<your-user>/geodata-toolkit.git\ncd geodata-toolkit\n\n# 2. create environment (conda recommended)\nconda env create -f environment.yml\nconda activate geodata\n\n# 3. launch JupyterLab / Notebook\njupyter lab   # or  jupyter notebook\n\n# 4. open a notebook and run all cells\n#    e.g. notebooks/make_rectangle_kml.ipynb\n","type":"content","url":"/#id-quick-start","position":7},{"hierarchy":{"lvl1":"Beijing 1954 (TIFF) âœ WGS 84 (EPSG:4326) â€” Raster Re-projection"},"type":"lvl1","url":"/beijing54-to-wgs84","position":0},{"hierarchy":{"lvl1":"Beijing 1954 (TIFF) âœ WGS 84 (EPSG:4326) â€” Raster Re-projection"},"content":"Convert a georeferenced raster from Beijing 1954 (aka Beijing 54) to WGS 84 using a table of ground-control points.\n\nWorkflow\n\nLoad control-point table (54_to_84.csv).\n\nAttach the GCPs (Beijing 54 âœ WGS 84) to the original TIFF.\n\nCall GDAL Warp (gdal.Warp) with a Thin-Plate Spline (TPS) or 1st-order polynomial transform.\n\nSave the re-projected raster as GeoTIFF in WGS 84.\n\n","type":"content","url":"/beijing54-to-wgs84","position":1},{"hierarchy":{"lvl1":"Beijing 1954 (TIFF) âœ WGS 84 (EPSG:4326) â€” Raster Re-projection","lvl2":"Requirements"},"type":"lvl2","url":"/beijing54-to-wgs84#requirements","position":2},{"hierarchy":{"lvl1":"Beijing 1954 (TIFF) âœ WGS 84 (EPSG:4326) â€” Raster Re-projection","lvl2":"Requirements"},"content":"conda install -c conda-forge gdal rasterio pyproj pandas\n\nGDAL â‰¥ 3.1 is recommended so that gdal.Warp can use the tps=True option.\n\nimport os\nfrom osgeo import gdal, osr\nimport pandas as pd\nfrom typing import List\n\n\n# ---- User inputs -------------------------------------------------------\ninput_tiff   = \"beijing54.tif\"         # Source raster (Beijing 54)\ngcps_csv     = \"54_to_84.csv\"          # Control-point table (CSV)\noutput_tiff  = \"beijing54_to_wgs84.tif\"\n\n# Transform method:  'tps' (thin-plate spline) or polynomial order (int)\ntransform_method = \"tps\"   # choose \"tps\" or 1/2/3 for polynomial order\n\n\n# The CSV must contain:\n#   x54, y54  â–¶ coordinates in Beijing 54 (same units as the raster)\n#   lon84, lat84 â–¶ WGS 84 geographic coordinates (decimal degrees)\ngdf = pd.read_csv(gcps_csv)\n\n# Open source raster\nsrc_ds = gdal.Open(input_tiff, gdal.GA_ReadOnly)\nif src_ds is None:\n    raise FileNotFoundError(f\"Cannot open {input_tiff}\")\n\ngt = src_ds.GetGeoTransform()\ninv_gt = gdal.InvGeoTransform(gt)\n\n# Build GCP list\ngdal_gcps: List[gdal.GCP] = []\nfor _, row in gdf.iterrows():\n    x54, y54 = float(row['x54']), float(row['y54'])\n    lon84, lat84 = float(row['lon84']), float(row['lat84'])\n    # Convert world â†’ pixel\n    px, py = gdal.ApplyGeoTransform(inv_gt, x54, y54)\n    gcp = gdal.GCP(lon84, lat84, 0, px, py)  # (lon, lat, z, pixel, line)\n    gdal_gcps.append(gcp)\n\nprint(f\"Loaded {len(gdal_gcps)} control points.\")\n\n\n# Create an in-memory VRT copy with GCPs\nvrt_path = \"/vsimem/tmp_with_gcps.vrt\"\ngdal.Translate(\n    vrt_path,\n    src_ds,\n    GCPs=gdal_gcps,\n    outputSRS=\"EPSG:4326\"  # Target GCP spatial ref (WGS 84)\n)\nsrc_ds = None  # close\n\n\nwarp_kwargs = dict(\n    dstSRS=\"EPSG:4326\",\n    format=\"GTiff\",\n    xRes=0.0002695,   # â‰ˆ 30 m at the equator â€” adjust as needed\n    yRes=0.0002695,\n    resampleAlg=\"bilinear\",\n    multithread=True\n)\n\nif transform_method == \"tps\":\n    warp_kwargs[\"tps\"] = True\nelse:\n    warp_kwargs[\"polynomialOrder\"] = int(transform_method)\n\ngdal.Warp(\n    destNameOrDestDS=output_tiff,\n    srcDSOrSrcDSTab=vrt_path,\n    **warp_kwargs\n)\n\nprint(f\"Warp complete âœ {output_tiff}\")\n\n\nds = gdal.Open(output_tiff)\nprint(\"Target CRS:\", ds.GetSpatialRef().ExportToWkt().split(',')[0])\nprint(\"Raster size :\", ds.RasterXSize, \"Ã—\", ds.RasterYSize)\nprint(\"GeoTransform:\", ds.GetGeoTransform())\nds = None\n\n\n\n\nTips\n\nIf you prefer to use a 1st-order polynomial instead of TPS, set transform_method = 1.\n\nIncrease the number of well-distributed control points for higher accuracy.\n\nxRes/yRes control the output resolution. Adjust to suit your data.","type":"content","url":"/beijing54-to-wgs84#requirements","position":3},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/kml-ouput","position":0},{"hierarchy":{"lvl1":""},"content":"import math\n\n# Center coordinates è¿™é‡Œæ›´æ”¹ä¸­å¿ƒåæ ‡ç‚¹\nlat0 = 39.8510179\nlon0 = 116.219730\n\n# Calculate half side length (meters) for a 10 kmÂ² square è¿™é‡Œå¯ä»¥æ›´æ”¹æ•°æ®èŒƒå›´ï¼Œä»¥10å¹³æ–¹å…¬é‡Œä¸ºä¾‹\nhalf_side = math.sqrt(10_000_000) / 2  # ~1581.14 m\n\n# Approximate degrees per meter \ndelta_lat = half_side / 111320  # degrees latitude per meter\nlat0_rad = math.radians(lat0)\ndelta_lon = half_side / (111320 * math.cos(lat0_rad))  # degrees longitude per meter\n\n# Calculate square corner coordinates (lon, lat)\ncoords = [\n    (lon0 - delta_lon, lat0 - delta_lat),\n    (lon0 + delta_lon, lat0 - delta_lat),\n    (lon0 + delta_lon, lat0 + delta_lat),\n    (lon0 - delta_lon, lat0 + delta_lat),\n    (lon0 - delta_lon, lat0 - delta_lat)\n]\n\n# Build KML content\nkml_content = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<kml xmlns=\"http://www.opengis.net/kml/2.2\">\n  <Placemark>\n    <name>10kmÂ² Square Area</name>\n    <Polygon>\n      <outerBoundaryIs>\n        <LinearRing>\n          <coordinates>\n\"\"\"\nfor lon, lat in coords:\n    kml_content += f\"            {lon},{lat},0\\n\"\nkml_content += \"\"\"          </coordinates>\n        </LinearRing>\n      </outerBoundaryIs>\n    </Polygon>\n  </Placemark>\n</kml>\n\"\"\"\n\n# Write to file\nfile_path = \"/kml/square_10km2.kml\"\nwith open(file_path, \"w\", encoding=\"utf-8\") as f:\n    f.write(kml_content)\n\nfile_path\n","type":"content","url":"/kml-ouput","position":1},{"hierarchy":{"lvl1":"Shapefile âœ Float32 GeoTIFF (DEPTH2D) â€” Interactive + Batch"},"type":"lvl1","url":"/shp2tif-workflow","position":0},{"hierarchy":{"lvl1":"Shapefile âœ Float32 GeoTIFF (DEPTH2D) â€” Interactive + Batch"},"content":"This notebook batchâ€‘converts every .shp file beneath a chosen root directory into GeoTIFF rasters while:\n\nrepairing invalid geometries to avoid artefacts (e.g., stray horizontal lines);\n\nensuring the output raster is â‰¤â€¯4096â€¯Ã—â€¯4096 pixels (adjusting pixel size if necessary; default target â‰ˆÂ 0.00001 degree);\n\nsaving each GeoTIFF inside a sibling tif/ folder alongside its source shapefile;\n\nwriting a quickâ€‘look PNG overlay (shapefile boundaryâ€¯+â€¯raster) for visual QA.\n\nInteractive singleâ€‘file test â€“ preview one .shp as a raster overlay without saving.\n\nBatch conversion â€“ scan timestampâ€‘named folders, convert each contained shapefile to 32â€‘bit float GeoTIFF (DEPTH2D band) named <timestamp>_<frame>.tif.\n\nDependencies\n\nGeoPandas â‰¥â€¯0.14\n\nShapely â‰¥â€¯2.0\n\nRasterio â‰¥â€¯1.3\n\nMatplotlib\n\nInstall (conda):conda create -n gis python=3.11 geopandas rasterio matplotlib -c conda-forge\nconda activate gis\n\nAll outputs limited to â‰¤â€¯4096Ã—4096 pixels; overlapping polygons merged with max DEPTH2D; nodata=-9999.\n\nimport warnings, math\nfrom pathlib import Path\nimport geopandas as gpd\nfrom shapely import make_valid\nimport rasterio\nfrom rasterio.transform import from_origin\nfrom rasterio.features import rasterize\nfrom rasterio.enums import MergeAlg\nimport matplotlib.pyplot as plt\n\n\n","type":"content","url":"/shp2tif-workflow","position":1},{"hierarchy":{"lvl1":"Shapefile âœ Float32 GeoTIFF (DEPTH2D) â€” Interactive + Batch","lvl3":"Configure I/O Paths"},"type":"lvl3","url":"/shp2tif-workflow#configure-i-o-paths","position":2},{"hierarchy":{"lvl1":"Shapefile âœ Float32 GeoTIFF (DEPTH2D) â€” Interactive + Batch","lvl3":"Configure I/O Paths"},"content":"\n\n# SINGLE TEST\ntest_shp = Path(r'D:/gis/single_test/one.shp')   # change\n\n# BATCH\nbatch_root   = Path(r'D:/gis/batch_root')        # each subâ€‘folder = timestamp\nbatch_output = Path(r'D:/gis/tif_output')\nbatch_output.mkdir(parents=True, exist_ok=True)\n\nprint('Batch root :', batch_root.resolve())\nprint('Output root:', batch_output.resolve())\n\n\n","type":"content","url":"/shp2tif-workflow#configure-i-o-paths","position":3},{"hierarchy":{"lvl1":"Shapefile âœ Float32 GeoTIFF (DEPTH2D) â€” Interactive + Batch","lvl3":"Parameters"},"type":"lvl3","url":"/shp2tif-workflow#parameters","position":4},{"hierarchy":{"lvl1":"Shapefile âœ Float32 GeoTIFF (DEPTH2D) â€” Interactive + Batch","lvl3":"Parameters"},"content":"\n\nPIXEL_LIMIT     = 4096\nPIXEL_SIZE_FINE = 1e-5    # deg pls defined by yourself\nNODATA          = -9999.0\n#MERGE_STRATEGY  = 'max'   # max/min/first\nFRAME_FIELD     = 'FRAME' # attribute for frame number\n\n\n","type":"content","url":"/shp2tif-workflow#parameters","position":5},{"hierarchy":{"lvl1":"Shapefile âœ Float32 GeoTIFF (DEPTH2D) â€” Interactive + Batch","lvl3":"Utilities"},"type":"lvl3","url":"/shp2tif-workflow#utilities","position":6},{"hierarchy":{"lvl1":"Shapefile âœ Float32 GeoTIFF (DEPTH2D) â€” Interactive + Batch","lvl3":"Utilities"},"content":"\n\ndef repair(gdf):\n    def _f(geom):\n        if geom is None or geom.is_empty:\n            return None\n        if not geom.is_valid:\n            try:\n                return make_valid(geom)\n            except Exception:\n                return geom.buffer(0)\n        return geom\n    gdf['geometry'] = gdf.geometry.apply(_f)\n    return gdf[~gdf.geometry.is_empty & gdf.geometry.notnull()]\n\ndef choose_px(bounds):\n    minx, miny, maxx, maxy = bounds\n    dx, dy = maxx - minx, maxy - miny\n    if dx/PIXEL_SIZE_FINE <= PIXEL_LIMIT and dy/PIXEL_SIZE_FINE <= PIXEL_LIMIT:\n        return PIXEL_SIZE_FINE\n    px = max(dx, dy)/PIXEL_LIMIT\n    if px > PIXEL_SIZE_FINE:\n        warnings.warn(f'Pixel size relaxed to {px:.6f}')\n    return px\n\ndef rasterize_depth(gdf):\n    minx, miny, maxx, maxy = gdf.total_bounds\n    px = choose_px((minx, miny, maxx, maxy))\n    width  = math.ceil((maxx - minx)/px)\n    height = math.ceil((maxy - miny)/px)\n    transform = from_origin(minx, maxy, px, px)\n\n    shapes = ((row.geometry, float(row['DEPTH2D'])) for _, row in gdf.iterrows())\n    arr = rasterize(shapes, out_shape=(height, width),\n                    fill=NODATA, dtype='float32',\n                    transform=transform)\n    return arr, transform\n\n\n","type":"content","url":"/shp2tif-workflow#utilities","position":7},{"hierarchy":{"lvl1":"Shapefile âœ Float32 GeoTIFF (DEPTH2D) â€” Interactive + Batch","lvl2":"1Â Â Interactive Preview"},"type":"lvl2","url":"/shp2tif-workflow#id-1-interactive-preview","position":8},{"hierarchy":{"lvl1":"Shapefile âœ Float32 GeoTIFF (DEPTH2D) â€” Interactive + Batch","lvl2":"1Â Â Interactive Preview"},"content":"\n\nif test_shp.exists():\n    gdf = gpd.read_file(test_shp)\n    if 'DEPTH2D' not in gdf.columns:\n        raise KeyError('DEPTH2D missing')\n    gdf = repair(gdf)\n    arr, transform = rasterize_depth(gdf)\n\n    minx, miny, maxx, maxy = gdf.total_bounds\n    fig, ax = plt.subplots(figsize=(6,6))\n    im = ax.imshow(arr, extent=[minx,maxx,miny,maxy], origin='upper', cmap='viridis', alpha=0.6)\n    gdf.boundary.plot(ax=ax, edgecolor='white', linewidth=0.4)\n    plt.colorbar(im, ax=ax, fraction=0.022, pad=0.01, label='DEPTH2D')\n    ax.set_axis_off()\n    plt.show()\nelse:\n    print('Set `test_shp` path to an existing shapefile for preview.')\n\n\n","type":"content","url":"/shp2tif-workflow#id-1-interactive-preview","position":9},{"hierarchy":{"lvl1":"Shapefile âœ Float32 GeoTIFF (DEPTH2D) â€” Interactive + Batch","lvl2":"2Â Â Batch Conversion"},"type":"lvl2","url":"/shp2tif-workflow#id-2-batch-conversion","position":10},{"hierarchy":{"lvl1":"Shapefile âœ Float32 GeoTIFF (DEPTH2D) â€” Interactive + Batch","lvl2":"2Â Â Batch Conversion"},"content":"\n\nfolders = [p for p in batch_root.iterdir() if p.is_dir()]\nprint(f'Folders found: {len(folders)}')\n\nfor ts_dir in folders:\n    timestamp = ts_dir.name\n    shp_paths = list(ts_dir.glob('*.shp'))\n    if not shp_paths:\n        print(f'[SKIP] {timestamp}: no shp')\n        continue\n    shp_path = shp_paths[0]\n\n    try:\n        gdf = gpd.read_file(shp_path)\n        if 'DEPTH2D' not in gdf.columns:\n            print(f'[SKIP] {shp_path.name}: DEPTH2D missing')\n            continue\n        gdf = repair(gdf)\n        frame_val = (str(gdf[FRAME_FIELD].dropna().iloc[0])\n                     if FRAME_FIELD in gdf.columns and not gdf[FRAME_FIELD].dropna().empty\n                     else shp_path.stem)\n        arr, transform = rasterize_depth(gdf)\n        out_tif = batch_output / f'{timestamp}_{frame_val}.tif'\n\n        meta = dict(driver='GTiff',\n                    height=arr.shape[0], width=arr.shape[1],\n                    count=1, dtype='float32', transform=transform,\n                    crs=gdf.crs, nodata=NODATA)\n\n        with rasterio.open(out_tif, 'w', **meta) as dst:\n            dst.write(arr, 1)\n\n        print(f'[OK] {timestamp}/{shp_path.name} â†’ {out_tif.name}')\n    except Exception as e:\n        print(f'[ERR] {shp_path}: {e}')\n","type":"content","url":"/shp2tif-workflow#id-2-batch-conversion","position":11},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/trans-crs","position":0},{"hierarchy":{"lvl1":""},"content":"# â”€â”€â”€ â‘  imports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nimport geopandas as gpd\nfrom pathlib import Path\nimport shutil, os\n\n# â”€â”€â”€ â‘¡ å‚æ•°é…ç½® â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\ninput_root  = Path(r'D:/gis/to_transform')     # å¾…è½¬æ¢æ–‡ä»¶æ ¹ç›®å½•\noutput_root = Path(r'D:/gis/transformed')      # è¾“å‡ºæ ¹ç›®å½•\noutput_root.mkdir(parents=True, exist_ok=True)\n\ntarget_crs = 'EPSG:4326'          # ç›®æ ‡ï¼šWGS-84\nassumed_source_crs = None         # å¦‚æœæ•°æ®æœ¬èº«æ²¡ CRSï¼Œè¯·åœ¨è¿™é‡Œå¡«å¦‚ 'EPSG:4547' ç­‰\n\n# â”€â”€â”€ â‘¢ æ ¸å¿ƒå‡½æ•° â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\ndef transform_vector(in_path: Path):\n    \"\"\"Read vector file, re-project to `target_crs`, write to mirror location.\"\"\"\n    try:\n        gdf = gpd.read_file(in_path)\n    except Exception as e:\n        print(f'[ERR] {in_path.name}: {e}')\n        return\n    \n    if gdf.crs is None:\n        if not assumed_source_crs:\n            print(f'[SKIP] {in_path.name}: no CRS & no assumed_source_crs.')\n            return\n        gdf = gdf.set_crs(assumed_source_crs)\n    \n    if str(gdf.crs).upper() == str(target_crs).upper():\n        print(f'[=] {in_path.name}: already in {target_crs}')\n        return\n    \n    gdf_out = gdf.to_crs(target_crs)\n    rel     = in_path.relative_to(input_root)\n    out_path = (output_root / rel).with_suffix('.shp')  # å§‹ç»ˆå†™ Shapefile\n    out_path.parent.mkdir(parents=True, exist_ok=True)\n    gdf_out.to_file(out_path)\n    print(f'[OK] {in_path} â†’ {out_path}')\n\n# â”€â”€â”€ â‘£ æ‰¹å¤„ç†æ‰§è¡Œ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nvector_exts = {'.shp', '.geojson', '.json', '.gpkg'}\nfiles = [p for p in input_root.rglob('*') if p.suffix.lower() in vector_exts]\n\nprint(f'Total vector files: {len(files)}')\nfor vec in files:\n    transform_vector(vec)","type":"content","url":"/trans-crs","position":1}]}